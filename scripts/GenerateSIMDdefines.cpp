#include <chrono>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>

#ifdef _MSC_VER
  #include <intrin.h>
#else
  #include <cpuid.h>
#endif

#define USE_LOCALTIME

#ifndef USE_LOCALTIME
  #define USE_GMT
#endif

auto g_getCurrentDateTime() -> std::string {
  std::ostringstream ss;
  auto               now = std::chrono::system_clock::now();
  auto               itt = std::chrono::system_clock::to_time_t(now);

  std::tm bt{};

#ifdef USE_GMT
  gmtime_s(&bt, &itt);
#else
  localtime_s(&bt, &itt);
#endif

  ss << std::put_time(&bt, "%Y-%m-%d %H:%M:%S");
  return ss.str();
}

auto main() -> int {
  std::string   defines_file_path = "src/lib/simd/precompiled/SIMDdefines.h";
  std::ofstream defines(defines_file_path);

  if (!defines) {
    std::cerr << "Failed to open " << defines_file_path << " for writing\n";
    return 1;
  } else {
    std::cout << "Successfully opened " << defines_file_path
              << " for writing\n";
  }
  std::cout << "Successfully opened " << defines_file_path << " for writing\n";

  std::string currentDateTime = g_getCurrentDateTime();

  // Doxygen comment
  defines << "/**\n"
          << " * @file " << defines_file_path << "\n"
          << " * @brief Defines the SIMD capabilities of the current CPU\n"
          << " * @date " << currentDateTime << "\n"
          << " *\n"
          << " * This file is generated by GenerateSIMDdefines.h during build "
             "of the project.\n"
          << " * It uses the CPUID instruction to detect the SIMD capabilities "
             "of the current\n"
          << " * CPU, and then writes corresponding preprocessor definitions "
             "to this file. The\n"
          << " * SIMD capabilities that are detected include SSE3, SSSE3, "
             "SSE4.1, SSE4.2, AVX,\n"
          << " * AVX2 and AVX512F.\n"
          << " */\n\n";

#ifdef _MSC_VER

  constexpr int kCpuidLeaf1 = 1;
  constexpr int kCpuidLeaf7 = 7;

  constexpr int kBitSse3    = 0;
  constexpr int kBitSsse3   = 9;
  constexpr int kBitSse41   = 19;
  constexpr int kBitSse42   = 20;
  constexpr int kBitAvx     = 28;
  constexpr int kBitAvx2    = 5;
  constexpr int kBitAvx512F = 16;

  std::array<int, 4> cpuInfo{};
  __cpuid(cpuInfo.data(), 0);

  int maxLeaf = cpuInfo[0];

  if (maxLeaf >= kCpuidLeaf1) {
    __cpuid(cpuInfo.data(), kCpuidLeaf1);

    if (cpuInfo[2] & (1 << kBitSse3)) {
      defines << "#define SUPPORTS_SSE3\n";
    }
    if (cpuInfo[2] & (1 << kBitSsse3)) {
      defines << "#define SUPPORTS_SSSE3\n";
    }
    if (cpuInfo[2] & (1 << kBitSse41)) {
      defines << "#define SUPPORTS_SSE4_1\n";
    }
    if (cpuInfo[2] & (1 << kBitSse42)) {
      defines << "#define SUPPORTS_SSE4_2\n";
    }
    if (cpuInfo[2] & (1 << kBitAvx)) {
      defines << "#define SUPPORTS_AVX\n";
    }
  }

  if (maxLeaf >= kCpuidLeaf7) {
    __cpuidex(cpuInfo.data(), kCpuidLeaf7, 0);

    if (cpuInfo[1] & (1 << kBitAvx2)) {
      defines << "#define SUPPORTS_AVX2\n";
    }
    if (cpuInfo[1] & (1 << kBitAvx512F)) {
      defines << "#define SUPPORTS_AVX512F\n";
    }
  }

#else
  unsigned int eax, ebx, ecx, edx;
  __get_cpuid(0, &eax, &ebx, &ecx, &edx);

  unsigned int maxLeaf = eax;

  if (maxLeaf >= 1) {
    __get_cpuid(1, &eax, &ebx, &ecx, &edx);

    if (ecx & bit_SSE3) {
      defines << "#define SUPPORTS_SSE3\n";
    }
    if (ecx & bit_SSSE3) {
      defines << "#define SUPPORTS_SSSE3\n";
    }
    if (ecx & bit_SSE4_1) {
      defines << "#define SUPPORTS_SSE4_1\n";
    }
    if (ecx & bit_SSE4_2) {
      defines << "#define SUPPORTS_SSE4_2\n";
    }
    if (ecx & bit_AVX) {
      defines << "#define SUPPORTS_AVX\n";
    }
  }

  if (maxLeaf >= 7) {
    __get_cpuid(7, &eax, &ebx, &ecx, &edx);

    if (ebx & (1 << 5)) {
      defines << "#define SUPPORTS_AVX2\n";
    }
    if (ebx & (1 << 16)) {
      defines << "#define SUPPORTS_AVX512F\n";
    }
  }

#endif

  return 0;
}
